# 				Werkzeug PIN Console with Django



#### **Ở phần trước chúng ta đã được biết Werkzeug là 1 phần không thể thiếu của Flask, cung cấp cho người dùng nhiều tiện ích, trong đó bao gồm 1 debugger ngay trên browser cực kì tiện lợi, nhưng mã PIN bảo vệ nó vẫn có thể bị tấn công. Tuy nhiên, liệu chúng ta có thể sử dụng Werkzeug cùng với 1 framework Python khác cũng phổ biến không kém Flask là Django? Và liệu cách khai thác mã PIN console sẽ thay đổi như thế nào? Chúng ta sẽ cùng nhau giải đáp những thắc mắc trên.**

> Bài viết này là phần tìm hiểu sâu hơn 1 chút so với bài viết trước, nên mình sẽ giả sử rằng người đọc đã biết về Werkzeug, PIN console cùng với cách exploit và tái tạo PIN để RCE. 

### Lợi ích của việc sử dụng Werkzeug cùng với Django

​	Khác với Flask, Werkzeug không đi kèm một cách mặc định cùng với Django. Tuy nhiên, Werkzeug lại đi kèm với 1 debugger với những lợi thế sau:

* Giao diện dễ nhìn, trực quan và có sẵn ngay trên browser

* AJAX-based cho phép execute code ngay trong context của bug

* Cho phép xem đoạn source code bị bug

  ![werkzeug-traceback](https://f.cloud.github.com/assets/202559/1261027/2637f826-2c22-11e3-83c6-646acc87808b.png)

Để sử dụng Werkzeug kèm với Django, chúng ta cần thông qua 1 extension [RunServerPlus](https://django-extensions.readthedocs.io/en/latest/runserver_plus.html). Sau đó chỉ cần chạy server như sau:

```bash
$ python manage.py runserver_plus

* Running on http://127.0.0.1:8000/
* Restarting with reloader...

Validating models...
0 errors found

Django version X.Y.Z, using settings 'screencasts.settings'
Development server is running at http://127.0.0.1:8000/
Using the Werkzeug debugger (https://werkzeug.palletsprojects.com/)
Quit the server with CONTROL-C.
```



Vậy là chúng ta đã set up thành công webapp Django cùng với Werkzeug. Tiếp theo chúng ta sẽ tìm hiểu xem quá trình tạo PIN có gì khác hơn so với Flask nhé.

### PIN Console generation 

Nhắc lại 1 chút về các giá trị cần để tạo PIN cho debugger. Dưới đây là 1 đoạn trích trong file werkzeug/debug/_\_init__.py:

```python
probably_public_bits = [
        username,
        modname,
        getattr(app, "__name__", type(app).__name__),
        getattr(mod, "__file__", None),
    ]

# This information is here to make it harder for an attacker to
# guess the cookie name.  They are unlikely to be contained anywhere
# within the unauthenticated debug page.
private_bits = [str(uuid.getnode()), get_machine_id()]
```



Như trong document trước chúng ta đã đề cập, trong quá trình tạo PIN sẽ cần đến 2 trường  **probably_public_bits** và **private_bits**. Chúng ta có thể thử so sánh sự khác biệt giữa Django và Flask thông qua source code tạo PIN.



1. **private_bits**

   Mình muốn bắt đầu với private_bit trước, bởi vì có vẻ như 2 giá trị trong trường này sẽ không bị ảnh hưởng dù chúng ta có sử dụng framework nào đi chăng nữa (Vì MAC address, machine-id hay boot-id cùng 1 máy sẽ không thay đổi). Nên cách khai thác của private_bits trên cả 2 framework đều như nhau.

2. **probably_public_bits**

   Với probably_public_bits có khả năng là có sự khác biệt giữa Django và Flask, bởi vì Django không mặc định có app.py như Flask để khai thác, nên các giá trị default thường thấy ở Flask sẽ không hoạt động trong trường hợp của Django. Chúng ta thử phân tích từng param xem nhé.

   (Tất cá các đoạn trích source code này đều nằm trong file /werkzeug/debug/\_\_init__.py của library Werkzeug)

   * username

     ```python
     username = getpass.getuser()
     ```

     Username của user chạy server. Vẫn không khác biệt lắm.

   * modname 

     ```python
     modname = getattr(app, "__module__", t.cast(object, app).__class__.__module__)
     ```

     Module name của application. giá trị default của werkzeug là WSGIApplication. Tuy nhiên với Flask thì nó sẽ có giá trị dựa theo app.py, trong khi đó Django thì không. Nên mình đoán sẽ có sự khác biệt ở đây

   * appname

     ```python
     getattr(app, "__name__", type(app).__name__)
     ```

     Nếu có sự khác biệt trong module name, thì app name cũng sẽ có sự khác biệt giữa 2 framework.

   * Path

     ```python
     mod = sys.modules.get(modname)
     #...
     #... Some codes python ...
     #...
     getattr(mod, "__file__", None)
     ```

     Nếu như với Flask, việc lấy path của app.py có thể thông qua màn hình debug, thì module nào được dùng trong trường hợp của Django cũng sẽ được hiển thị tương tự với Flask, nên việc lấy được path dẫn đến module này cũng sẽ tương tự với app.py, chỉ là với giá trị khác.



Chúng ta có thể đoán được, sự khác biệt lớn nhất giữa Django và Flask trong việc tạo PIN cho debugger nằm ở sự khác nhau giữa các module, dẫn đến sự khác biệt về 2 params module name và app name. Tuy nhiên, nếu như trên server đã tồn tại 1 lỗ hổng cho phép lấy các thông tin trên (ví dụ như LFI đã được đề cập trong lần trước chẳng hạn), thì việc đọc source của chính file module và bruteforce các app name là hoàn toàn khả thi.

### Kết luận

Vậy là chúng ta đã tìm hiểu sâu hơn về việc sử dụng Werkzeug không chỉ với Flask, mà còn có thể với Django cũng như phân tích sự khác nhau trong quá trình tạo PIN giữa 2 framework. Để thấy rõ hơn các phân tích trên cũng như hiểu sâu hơn quá trình khai thác, mọi người có thể thử thực hành với tutorial bên dưới. Cảm ơn mọi người đã dành thời gian đọc document này và mình hy vọng sẽ nhận được những lời góp ý để cải thiện hơn cho những bài sau. Happy Hacking!



### Hướng dẫn tự tạo lab

Để hiểu rõ hơn quá trình tạo PIN, cũng như xem các giá trị cần thiết chúng ta có thể tạo 1 lab đơn giản với Django và runserverplus extension thông qua các bước sau:

1. Installation

​		Install Django, werkzeug, runserverplus và các dependancies.

​		Set-up 1 minimal web application

2. Chỉnh sửa file _\_innit__.py:

   Thông thường, kể cả với Flask hay Django thì Werkzeug không hiển thị các tham số dùng để tạo PIN mà chỉ hiển thị PIN. Tuy nhiên chúng ta có thể sửa source code 1 chút để thấy rõ hơn các giá trị được dùng bằng cách sau:

   * Xác định vị trí thư viện werkzeug: thường thì ở /path/to/python3.XX/site-packages/werkzeug/

   * Mở file ./debug/_\_innit__.py bằng editor và thêm vào đoạn code sau:

     ```python
     # This information only exists to make the cookie unique on the
     # computer, not as a security feature.
     probably_public_bits = [
     username,
     modname,
     getattr(app, "__name__", type(app).__name__),
     getattr(mod, "__file__", None),
     ]
     
     # This information is here to make it harder for an attacker to
     # guess the cookie name.  They are unlikely to be contained anywhere
     # within the unauthenticated debug page.
     private_bits = [str(uuid.getnode()), get_machine_id()]
     
     ### Add these line to the code ###
     print(f'public_bits: {probably_public_bits}')
     print(f'private_bits: {private_bits}')
     ```

   3. Chạy server với dòng lệnh:

      ```python
      python manage.py runserver_plus
      ```



Giờ ở trên terminal, ngoài mã PIN ra chúng ta còn có thể thấy các giá trị đã được sử dụng để tạo ra nó. Nếu muốn chúng ta cũng có thể tạo ra bug đơn giản để thử tạo lab tự luyện tập ngay trên môi trường của mình.